Description: ensure that comparison operators do not mess up the MEM_Dyn flag on registers when reverting affinity changes
 The sqlite3VdbeExec function in vdbe.c in SQLite before 3.8.9 does not
 properly implement comparison operators, which allows context-dependent
 attackers to cause a denial of service (invalid free operation) or possibly
 have unspecified other impact via a crafted CHECK clause, as demonstrated by
 CHECK(0&O>O) in a CREATE TABLE statement.
Bug-Debian: https://bugs.debian.org/783968
Author: D. Richard Hipp
Origin: upstream, https://www.sqlite.org/src/info/02e3c88fbf6abdcf3975fb0fb71972b0ab30da30
Last-Update: 2015-05-02

---

--- sqlite3-3.8.7.1.orig/src/vdbe.c
+++ sqlite3-3.8.7.1/src/vdbe.c
@@ -1905,11 +1905,15 @@ case OP_Ge: {             /* same as TK_
         testcase( pIn1->flags & MEM_Int );
         testcase( pIn1->flags & MEM_Real );
         sqlite3VdbeMemStringify(pIn1, encoding, 1);
+        testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) );
+        flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask);
       }
       if( (pIn3->flags & MEM_Str)==0 && (pIn3->flags & (MEM_Int|MEM_Real))!=0 ){
         testcase( pIn3->flags & MEM_Int );
         testcase( pIn3->flags & MEM_Real );
         sqlite3VdbeMemStringify(pIn3, encoding, 1);
+        testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) );
+        flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask);
       }
     }
     assert( pOp->p4type==P4_COLLSEQ || pOp->p4.pColl==0 );
@@ -1946,7 +1950,9 @@ case OP_Ge: {             /* same as TK_
     }
   }
   /* Undo any changes made by applyAffinity() to the input registers. */
+  assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );
   pIn1->flags = flags1;
+  assert( (pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn) );
   pIn3->flags = flags3;
   break;
 }
